#+STARTUP: overview
#+STARTUP: indent

* Chapter 3. Defining Types, Streamlining Functions
[[https://book.realworldhaskell.org/read/defining-types-streamlining-functions.html][Chapter Online]].

* Exercises
** Exercise 1
Exercise 1 from [[https://book.realworldhaskell.org/read/defining-types-streamlining-functions.html#id585938][the exercises]].

*** Problem
Examine the type `List` below

#+BEGIN_SRC haskell :results value

:{
data List a = Cons a (List a) | Nil
  deriving (Show)

fromList (x:xs) = Cons x (fromList xs)
fromList []     = Nil
:}

(fromList "tom", fromList [1..2])

#+END_SRC

#+RESULTS:
| Cons | t | (Cons o (Cons m Nil)) | Cons | 1 | (Cons 2 Nil) |

Write the converse of `fromList` for the `List` type: a function that takes a
`List a` and generates a `[a]`.

*** Solution
**** Example 1

#+BEGIN_SRC haskell :results value

:{
-- Cl - Common Lisp style list
-- Hs - Haskell style list
data ClList a = Cons a (ClList a) | Nil
  deriving (Show)

fromHs2Cl :: [a] -> ClList a
fromHs2Cl []     = Nil
fromHs2Cl (x:xs) = Cons x (fromHs2Cl xs)

fromCl2Hs :: ClList a -> [a]
fromCl2Hs Nil         = []
fromCl2Hs (Cons x xs) = x : fromCl2Hs xs
:}

(fromCl2Hs $ fromHs2Cl "tom", fromCl2Hs $ fromHs2Cl [1..2])

#+END_SRC

#+RESULTS:
| tom | (1 2) |

**** Example 2

#+BEGIN_SRC haskell :results value

:{
-- Cl - Common Lisp style list
-- Hs - Haskell style list
data ClList a = Cons a (ClList a) | Nil
  deriving (Show)

fromHs2Cl :: [a] -> ClList a
fromHs2Cl xs = foldr (\cur acc -> Cons cur acc) Nil xs

fromCl2Hs :: ClList a -> [a]
fromCl2Hs Nil         = []
fromCl2Hs (Cons x xs) = x : fromCl2Hs xs
:}

(fromCl2Hs $ fromHs2Cl "tom", fromCl2Hs $ fromHs2Cl [1..2])

#+END_SRC

#+RESULTS:
| tom | (1 2) |

** Exercise 2
Exercise 2 from [[https://book.realworldhaskell.org/read/defining-types-streamlining-functions.html#id585938][the exercises]].

*** Problem
Examine the type `Tree` below

#+BEGIN_SRC haskell :results value

:{
data Tree a = Node a (Tree a) (Tree a) | Empty
  deriving (Show)
:}

#+END_SRC

Define a tree type that has only one constructor, like our [[https://book.realworldhaskell.org/read/defining-types-streamlining-functions.html#Tree.java:Tree][Java example]]. Instead
of the `Empty` constructor, use the `Maybe` type to refer to a node's children.

*** Solution
**** Example 1

#+BEGIN_SRC haskell :results value

:{
data Tree a = Node (Maybe a) (Maybe (Tree a)) (Maybe (Tree a)) deriving Show

simpleTree = Node (Just 5) Nothing Nothing
:}

simpleTree

#+END_SRC

#+RESULTS:
: Node (Just 5) Nothing Nothing

**** Example 2

#+BEGIN_SRC haskell :results value

:{
data Tree a = Node (Maybe a) (Maybe (Tree a)) (Maybe (Tree a)) deriving Show

simpleTree = Node (Just 5)
  Nothing
  (Just (Node (Just 6) Nothing Nothing))
:}

simpleTree

#+END_SRC

#+RESULTS:
: Node (Just 5) Nothing (Just (Node (Just 6) Nothing Nothing))

**** Example 3

#+BEGIN_SRC haskell :results value

:{
data Tree a = Node (Maybe a) (Maybe (Tree a)) (Maybe (Tree a)) deriving Show

simpleTree = Node (Just 5)
  (Just (Node (Just 2) Nothing Nothing))
  Nothing
:}

simpleTree

#+END_SRC

#+RESULTS:
: Node (Just 5) (Just (Node (Just 2) Nothing Nothing)) Nothing

**** Example 4

#+BEGIN_SRC haskell :results value

:{
data Tree a = Node (Maybe a) (Maybe (Tree a)) (Maybe (Tree a)) deriving Show

simpleTree = Node (Just 5)
  (Just (Node (Just 2) Nothing Nothing))
  (Just (Node (Just 6) Nothing Nothing))
:}

simpleTree

#+END_SRC

#+RESULTS:
: Node (Just 5) (Just (Node (Just 2) Nothing Nothing)) (Just (Node (Just 6) Nothing Nothing))

** Exercise 3
Actually it's exercise 1 and 2 from [[https://book.realworldhaskell.org/read/defining-types-streamlining-functions.html#id587860][the exercises]].

*** Problem
Write a function that computes the number of elements in a list. To test it,
ensure that it gives the same answers as the standard `length` function.
Add type to your function.

*** Solution
**** Example 1

#+BEGIN_SRC haskell :results value

:{
len' :: [a] -> Int -> Int
len' [] acc     = acc
len' (x:xs) acc = len' xs (acc + 1)

len :: [a] -> Int
len xs = len' xs 0

doesWorkAsLength :: [a] -> Bool
doesWorkAsLength xs = length xs == len xs
:}

map len $ [] : map (\n -> [1..n]) [1..10]

#+END_SRC

#+RESULTS:
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |

**** Example 2

#+BEGIN_SRC haskell :results value

:{
len :: [a] -> Int
len xs = foldl (\acc _ -> acc + 1) 0 xs

doesWorkAsLength :: [a] -> Bool
doesWorkAsLength xs = length xs == len xs
:}

map doesWorkAsLength $ [] : map (\n -> [1..n]) [1..10]

#+END_SRC

#+RESULTS:
| True | True | True | True | True | True | True | True | True | True | True |

**** Example 3

#+BEGIN_SRC haskell :results value

:{
len :: [a] -> Int
len = foldl (\acc _ -> acc + 1) 0

doesWorkAsLength :: [a] -> Bool
doesWorkAsLength xs = length xs == len xs
:}

and $ map doesWorkAsLength $ [] : map (\n -> [1..n]) [1..10]

#+END_SRC

#+RESULTS:
: True

** Exercise 4
Actually it's exercise 3 from [[https://book.realworldhaskell.org/read/defining-types-streamlining-functions.html#id587860][the exercises]].

*** Problem
Write a function that computes the mean of a list, i.e. the sum of all elements
in the list divided by its length. (You may need to use the `fromIntegral`
function to convert the length of the list from an integer into a floating point
number.

*** Solution

#+BEGIN_SRC haskell :results value

:{
getAvg :: [Double] -> Double
getAvg xs = sum xs / fromIntegral  (length xs)
:}

map getAvg $ map (\n -> [1..n]) [1..10]

#+END_SRC

#+RESULTS:
| 1.0 | 1.5 | 2.0 | 2.5 | 3.0 | 3.5 | 4.0 | 4.5 | 5.0 | 5.5 |

** Exercise 5
Actually it's exercise 4 from [[https://book.realworldhaskell.org/read/defining-types-streamlining-functions.html#id587860][the exercises]].

*** Problem
Turn a list into a palindrome, i.e. it should read the same both backwards and
forwards. For example, given the list [1,2,3], your function should return
[1,2,3,3,2,1].

*** Solution

**** Example 1

#+BEGIN_SRC haskell :results value

:{
-- insted of built-in reverse
rev' :: [a] -> [a] -> [a]
rev' [] sx     = sx
rev' (x:xs) sx = rev' xs $ x:sx

-- insted of built-in reverse
rev :: [a] -> [a]
rev xs = rev' xs []

turnList2palindrome :: [a] -> [a]
turnList2palindrome xs = xs ++ rev xs
:}

turnList2palindrome [3,2..1]

#+END_SRC

#+RESULTS:
| 3 | 2 | 1 | 1 | 2 | 3 |

**** Example 2

#+BEGIN_SRC haskell :results value

:{
turnList2palindrome :: [a] -> [a]
turnList2palindrome xs = xs ++ reverse xs
:}

turnList2palindrome [1..3]

#+END_SRC

#+RESULTS:
| 1 | 2 | 3 | 3 | 2 | 1 |

** Exercise 6
Actually it's exercise 5 from [[https://book.realworldhaskell.org/read/defining-types-streamlining-functions.html#id587860][the exercises]].

*** Problem
Write a function that determines whether its input list is a palindrome.

*** Solution

**** Example 1

#+BEGIN_SRC haskell :results value

:{
-- insted of built-in reverse
rev' :: [a] -> [a] -> [a]
rev' [] sx     = sx
rev' (x:xs) sx = rev' xs $ x:sx

-- insted of built-in reverse
rev :: [a] -> [a]
rev xs = rev' xs []

areEqual :: (Eq a) => [a] -> [a] -> Bool
areEqual [] [] = True
areEqual [] ys = False
areEqual xs [] = False
areEqual (x:xs) (y:ys)
  | x /= y = False
  | otherwise = areEqual xs ys

isPalindrome :: (Eq a) => [a] -> Bool
isPalindrome xs = areEqual xs $ rev xs
:}

map isPalindrome [[True, False, True], [False], [False, True, True]]

#+END_SRC

#+RESULTS:
| True | True | False |

**** Example 2

#+BEGIN_SRC haskell :results value

:{
-- insted of built-in reverse
rev :: [a] -> [a]
rev xs = foldl (flip (:)) [] xs
-- or even
-- rev = foldl (flip (:)) []

areEqual :: (Eq a) => [a] -> [a] -> Bool
areEqual [] [] = True
areEqual [] ys = False
areEqual xs [] = False
areEqual (x:xs) (y:ys)
  | x /= y = False
  | otherwise = areEqual xs ys

isPalindrome :: (Eq a) => [a] -> Bool
isPalindrome xs = areEqual xs $ rev xs
:}

map isPalindrome ["abccba", "abcba", "abcda"]

#+END_SRC

#+RESULTS:
| True | True | False |

**** Example 3

#+BEGIN_SRC haskell :results value

:{
isPalindrome :: (Eq a) => [a] -> Bool
isPalindrome xs = and $ zipWith (==) xs $ reverse xs
:}

map isPalindrome [[1, 2, 3, 1], [1, 3, 1]]

#+END_SRC

#+RESULTS:
| False | True |

** Exercise 7
Actually it's exercise 6 from [[https://book.realworldhaskell.org/read/defining-types-streamlining-functions.html#id587860][the exercises]].

*** Problem
Create a function that sorts a list of lists based on the length of each
sublist. (You may want to look at the `sortBy` function from the `Data.List`
module.)

*** Solution

**** Example 1

#+BEGIN_SRC haskell :results value

:{
import           Data.List (sortBy)

getLstOrdering :: [a] -> [a] -> Ordering
getLstOrdering xs ys = compare (length xs) (length ys)

sortLstsByLen :: [[a]] -> [[a]]
sortLstsByLen xxs = sortBy getLstOrdering xxs
:}

sortLstsByLen [[1, 2], [1], [1, 2, 3]]

#+END_SRC

#+RESULTS:
| 1 |   |   |
| 1 | 2 |   |
| 1 | 2 | 3 |

**** Example 2

#+BEGIN_SRC haskell :results value

:{
import           Data.List (sortBy)

getLstOrdering :: [a] -> [a] -> Ordering
getLstOrdering xs ys = compare (length xs) (length ys)

sortLstsByLen :: [[a]] -> [[a]]
sortLstsByLen = sortBy getLstOrdering
:}

sortLstsByLen ["jerry", "tom", "&"]

#+END_SRC

#+RESULTS:
| & | tom | jerry |

** Exercise 8
Actually it's exercise 7 from [[https://book.realworldhaskell.org/read/defining-types-streamlining-functions.html#id587860][the exercises]].

*** Problem

Define a function that joins a list of lists together using a separator value.

```
intersperse :: a -> \[[a]\] -> [a]
```

The separator should appear between elements of the list, but should not follow
the last element. Your function should behave as follows.

```
ghci> intersperse ',' []
""
ghci> intersperse ',' ["foo"]
"foo"
ghci> intersperse ',' ["foo","bar","baz","quux"]
"foo,bar,baz,quux"
```

*** Solution

**** Example 1

#+BEGIN_SRC haskell :results value

:{
intersperse' :: [[a]] -> [a] -> a -> [a]
intersperse' [] acc _       = acc
intersperse' (x:xs) [] sep  = intersperse' xs x sep
intersperse' (x:xs) acc sep = intersperse' xs (acc <> [sep] <> x) sep

intersperse :: a -> [[a]] -> [a]
intersperse sep xs = intersperse' xs [] sep
:}

(intersperse ',' ["foo"], intersperse ',' ["foo","bar","baz","quux"], intersperse ',' [])

#+END_SRC

#+RESULTS:
| foo | foo,bar,baz,quux |   |

**** Example 2

#+BEGIN_SRC haskell :results value

:{
intersperse :: a -> [[a]] -> [a]
intersperse sep [] = []
intersperse sep xs = foldl1 (\acc cur -> acc <> [sep] <> cur) xs
:}

(intersperse ',' ["foo"], intersperse ',' ["foo","bar","baz","quux"], intersperse ',' [])

#+END_SRC

#+RESULTS:
| foo | foo,bar,baz,quux |   |

* Note
You may need to surround the code snippets with `:{` and `:}`. [[https://emacs.stackexchange.com/questions/48446/haskell-code-execution-in-org-mode-give-error-but-in-hs-file-the-code-is-good-a][Explanation]].

* Warning
The content of this file may be incorrect, erroneous and/or harmful. Use it at Your own risk.
