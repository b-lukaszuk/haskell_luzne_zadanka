#+STARTUP: overview
#+STARTUP: indent

* Chapter 3. Defining Types, Streamlining Functions
[[https://book.realworldhaskell.org/read/defining-types-streamlining-functions.html][Chapter Online]].

* Exercises
** Exercise 1
Exercise 1 from [[https://book.realworldhaskell.org/read/defining-types-streamlining-functions.html#id585938][the exercises]].

*** Problem
Examine the type `List` below

#+BEGIN_SRC haskell :results value

:{
data List a = Cons a (List a) | Nil
  deriving (Show)

fromList (x:xs) = Cons x (fromList xs)
fromList []     = Nil
:}

(fromList "tom", fromList [1..2])

#+END_SRC

#+RESULTS:
| Cons | t | (Cons o (Cons m Nil)) | Cons | 1 | (Cons 2 Nil) |

Write the converse of `fromList` for the `List` type: a function that takes a
`List a` and generates a `[a]`.

*** Solution

#+BEGIN_SRC haskell :results value

:{
-- Cl - Common Lisp style list
-- Hs - Haskell style list
data ClList a = Cons a (ClList a) | Nil
  deriving (Show)

fromHs2Cl :: [a] -> ClList a
fromHs2Cl []     = Nil
fromHs2Cl (x:xs) = Cons x (fromHs2Cl xs)

fromCl2Hs :: ClList a -> [a]
fromCl2Hs Nil         = []
fromCl2Hs (Cons x xs) = x : fromCl2Hs xs
:}

(fromCl2Hs $ fromHs2Cl "tom", fromCl2Hs $ fromHs2Cl [1..2])

#+END_SRC

#+RESULTS:
| tom | (1 2) |

** Exercise 2
Exercise 2 from [[https://book.realworldhaskell.org/read/defining-types-streamlining-functions.html#id585938][the exercises]].

*** Problem
Examine the type `Tree` below

#+BEGIN_SRC haskell :results value

:{
data Tree a = Node a (Tree a) (Tree a) | Empty
  deriving (Show)
:}

#+END_SRC

Define a tree type that has only one constructor, like our [[https://book.realworldhaskell.org/read/defining-types-streamlining-functions.html#Tree.java:Tree][Java example]]. Instead
of the `Empty` constructor, use the `Maybe` type to refer to a node's children.

*** Solution
**** Example 1

#+BEGIN_SRC haskell :results value

:{
data Tree a = Node (Maybe a) (Maybe (Tree a)) (Maybe (Tree a)) deriving Show

simpleTree = Node (Just 5) Nothing Nothing
:}

simpleTree

#+END_SRC

#+RESULTS:
: Node (Just 5) Nothing Nothing

**** Example 2

#+BEGIN_SRC haskell :results value

:{
data Tree a = Node (Maybe a) (Maybe (Tree a)) (Maybe (Tree a)) deriving Show

simpleTree = Node (Just 5)
  Nothing
  (Just (Node (Just 6) Nothing Nothing))
:}

simpleTree

#+END_SRC

#+RESULTS:
: Node (Just 5) Nothing (Just (Node (Just 6) Nothing Nothing))

**** Example 3

#+BEGIN_SRC haskell :results value

:{
data Tree a = Node (Maybe a) (Maybe (Tree a)) (Maybe (Tree a)) deriving Show

simpleTree = Node (Just 5)
  (Just (Node (Just 2) Nothing Nothing))
  Nothing
:}

simpleTree

#+END_SRC

#+RESULTS:
: Node (Just 5) (Just (Node (Just 2) Nothing Nothing)) Nothing

**** Example 4

#+BEGIN_SRC haskell :results value

:{
data Tree a = Node (Maybe a) (Maybe (Tree a)) (Maybe (Tree a)) deriving Show

simpleTree = Node (Just 5)
  (Just (Node (Just 2) Nothing Nothing))
  (Just (Node (Just 6) Nothing Nothing))
:}

simpleTree

#+END_SRC

#+RESULTS:
: Node (Just 5) (Just (Node (Just 2) Nothing Nothing)) (Just (Node (Just 6) Nothing Nothing))

** Exercise 3
Actually it's exercise 1 and 2 from [[https://book.realworldhaskell.org/read/defining-types-streamlining-functions.html#id587860][the exercises]].

*** Problem
Write a function that computes the number of elements in a list. To test it,
ensure that it gives the same answers as the standard `length` function.
Add type to your function.

*** Solution
**** Example 1

#+BEGIN_SRC haskell :results value

:{
len' :: [a] -> Int -> Int
len' [] acc     = acc
len' (x:xs) acc = len' xs (acc + 1)

len :: [a] -> Int
len xs = len' xs 0
:}

map len $ [] : map (\n -> [1..n]) [1..10]

#+END_SRC

#+RESULTS:
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |

**** Example 2

#+BEGIN_SRC haskell :results value

:{
len' :: [a] -> Int -> Int
len' [] acc     = acc
len' (x:xs) acc = len' xs (acc + 1)

len :: [a] -> Int
len xs = len' xs 0

doesWorkAsLength :: [a] -> Bool
doesWorkAsLength xs = (length xs) == (len xs)
:}

map doesWorkAsLength $ [] : map (\n -> [1..n]) [1..10]

#+END_SRC

#+RESULTS:
| True | True | True | True | True | True | True | True | True | True | True |

**** Example 3

#+BEGIN_SRC haskell :results value

:{
len' :: [a] -> Int -> Int
len' [] acc     = acc
len' (x:xs) acc = len' xs (acc + 1)

len :: [a] -> Int
len xs = len' xs 0

doesWorkAsLength :: [a] -> Bool
doesWorkAsLength xs = (length xs) == (len xs)
:}

and $ map doesWorkAsLength $ [] : map (\n -> [1..n]) [1..10]

#+END_SRC

#+RESULTS:
: True

** Exercise 4
Actually it's exercise 3 from [[https://book.realworldhaskell.org/read/defining-types-streamlining-functions.html#id587860][the exercises]].

*** Problem
Write a function that computes the mean of a list, i.e. the sum of all elements
in the list divided by its length. (You may need to use the `fromIntegral`
function to convert the length of the list from an integer into a floating point
number.

*** Solution

#+BEGIN_SRC haskell :results value

:{
getAvg :: [Double] -> Double
getAvg xs = (sum xs) / (fromIntegral $ length xs)
:}

map getAvg $ map (\n -> [1..n]) [1..10]

#+END_SRC

#+RESULTS:
| 1.0 | 1.5 | 2.0 | 2.5 | 3.0 | 3.5 | 4.0 | 4.5 | 5.0 | 5.5 |

** Exercise 5
Actually it's exercise 4 from [[https://book.realworldhaskell.org/read/defining-types-streamlining-functions.html#id587860][the exercises]].

*** Problem
Turn a list into a palindrome, i.e. it should read the same both backwards and
forwards. For example, given the list [1,2,3], your function should return
[1,2,3,3,2,1].

*** Solution

#+BEGIN_SRC haskell :results value

:{
turnList2palindrome :: [a] -> [a]
turnList2palindrome xs = xs ++ reverse xs
:}

turnList2palindrome [1..3]

#+END_SRC

#+RESULTS:
| 1 | 2 | 3 | 3 | 2 | 1 |
* Note
You may need to surround the code snippets with `:{` and `:}`. [[https://emacs.stackexchange.com/questions/48446/haskell-code-execution-in-org-mode-give-error-but-in-hs-file-the-code-is-good-a][Explanation]].

* Warning
The content of this file may be incorrect, erroneous and/or harmful. Use it at Your own risk.
