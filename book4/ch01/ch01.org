#+STARTUP: overview
#+STARTUP: indent

* 1. Building Abstractions with procedures
** 1.1 The Elements of Programming
*** 1.1.1 Expressions

#+BEGIN_SRC haskell :results value

  [486, 137 + 349, 1000 - 334, 5 * 99, 10 / 5, 2.7 + 10]

#+END_SRC

etc.

*** 1.1.2 Naming and the Environment

#+BEGIN_SRC haskell :results value

  circumference :: Floating a => a -> a
  circumference r = 2 * pi * r

  map circumference [10, 50]

#+END_SRC

*** 1.1.4 Compound Procedures

Square number

#+BEGIN_SRC haskell :results value

  square :: Num a => a -> a
  square x = x * x

  map square [21, 2+5, square 3]

#+END_SRC

Sum of Squares

#+BEGIN_SRC haskell :results value

 sumOfSquares :: Num a => a -> a -> a
 sumOfSquares x y = (square x) + (square y)

 sumOfSquares 3 4

#+END_SRC

Further procedure

#+BEGIN_SRC haskell :results value

  f :: Num a => a -> a
  f a = sumOfSquares (a + 1) (a * 2)

  f 5

#+END_SRC

*** 1.1.6 Conditional Expressions and Predicates

Version 1

#+BEGIN_SRC haskell :results value

 myAbs :: (Ord a, Num a) => a -> a
 myAbs x
   | x > 0 = x
   | x == 0 = 0
   | otherwise = negate x

 map myAbs [-5..5]

#+END_SRC

Version 2

#+BEGIN_SRC haskell :results value

 myAbs' :: (Ord a, Num a) => a -> a
 myAbs' x = if (x < 0) then negate x else x

 map myAbs' [-5..5]

#+END_SRC

*** 1.1.7 Example: Square Roots by Newton's Method

#+BEGIN_SRC haskell :results value

 getAvg :: Fractional a => a -> a -> a
 getAvg x y = (x + y) / 2

 improveSqrt :: Fractional a => a -> a -> a
 improveSqrt guess x = getAvg guess (x / guess)

 isGoodEnoughSqrt :: (Ord a, Fractional a) => a -> a -> Bool
 isGoodEnoughSqrt guess x = (abs ((square guess) - x)) < 0.001

 getSqrtIter' :: (Ord a, Fractional a) => a -> a -> a
 getSqrtIter' guess x =
   if (isGoodEnoughSqrt guess x)
   then guess
   else getSqrtIter' (improveSqrt guess x) x

 getSqrtIter :: (Ord a, Fractional a) => a -> a
 getSqrtIter x = getSqrtIter' 1 x

 map getSqrtIter [4..9]

#+END_SRC

** 1.2 Procedures and the Process They Generate
*** 1.2.1 Linear Recursion and Iteration

#+BEGIN_SRC haskell :results value

 factorial :: Natural -> Natural
 factorial n = if (n <= 0) then 1 else n * factorial (n-1)

 factIter :: Natural -> Natural -> Natural -> Natural
 factIter product counter maxCount
   | counter > maxCount = product
   | otherwise = factIter (counter * product) (counter + 1) maxCount

 factorial' :: Natural -> Natural
 factorial' n = factIter 1 1 n

 factorial' 5

#+END_SRC

** Exercises
*** Ex. 1.3
Define a procedure that takes three numbers as arguments and returns the sum of
the squares of the two larger numbers.

#+BEGIN_SRC haskell :results value

  getSumOfSquaresOfBigNums :: (Ord a, Num a) => a -> a -> a -> a
  getSumOfSquaresOfBigNums x y z
    | (x < y) && (x < z) = sumOfSquares y z
    | (y < x) && (y < z) = sumOfSquares x z
    | otherwise = sumOfSquares x y

  getSumOfSquaresOfBigNums 2 3 4

#+END_SRC

*** Ex. 1.8

Newton's method for cube roots.

#+BEGIN_SRC haskell :results value

 cube :: Num a => a -> a
 cube x = x * x * x

 improveCbrt :: Fractional a => a -> a -> a
 improveCbrt guess x = numerator / 3
   where numerator = (x / square guess) + 2 * guess

 isGoodEnoughCbrt :: (Ord a, Fractional a) => a -> a -> Bool
 isGoodEnoughCbrt guess x = (abs ((cube guess) - x)) < 0.001

 getCbrtIter' :: (Ord a, Fractional a) => a -> a -> a
 getCbrtIter' guess x =
   if (isGoodEnoughCbrt guess x)
   then guess
   else getCbrtIter' (improveCbrt guess x) x

 getCbrtIter :: (Ord a, Fractional a) => a -> a
 getCbrtIter x = getCbrtIter' 1 x

 getCbrtIter 27

#+END_SRC

*** Ex. 1.10

Ackermann's function.

#+BEGIN_SRC haskell :results value

  -- m and n are >= 0
  -- computationally expensive, recommendation use with: m <= 3, n <= 4
  ackermann :: Natural -> Natural -> Natural
  ackermann m n
    | m == 0 = n + 1
    | n == 0 = ackermann (m - 1) 1
    | otherwise = ackermann (m - 1) (ackermann m (n - 1))

  ackermann 3 4

#+END_SRC
