#+STARTUP: overview
#+STARTUP: indent

* 1. Building Abstractions with procedures
** 1.1 The Elements of Programming
*** 1.1.1 Expressions

#+BEGIN_SRC haskell :session s1 :results value

  [486, 137 + 349, 1000 - 334, 5 * 99, 10 / 5, 2.7 + 10]

#+END_SRC

etc.

*** 1.1.2 Naming and the Environment

#+BEGIN_SRC haskell :session s1 :results value

  circumference :: Floating a => a -> a
  circumference r = 2 * pi * r

  map circumference [10, 50]

#+END_SRC

*** 1.1.4 Compound Procedures

Square number

#+BEGIN_SRC haskell :session s1 :results value

  square :: Num a => a -> a
  square x = x * x

  map square [21, 2+5, square 3]

#+END_SRC

Sum of Squares

#+BEGIN_SRC haskell :session s1 :results value

  sumOfSquares :: Num a => a -> a -> a
  sumOfSquares x y = (square x) + (square y)

  sumOfSquares 3 4

#+END_SRC

Further procedure

#+BEGIN_SRC haskell :session s1 :results value

  f :: Num a => a -> a
  f a = sumOfSquares (a + 1) (a * 2)

  f 5

#+END_SRC

*** 1.1.6 Conditional Expressions and Predicates

Version 1

#+BEGIN_SRC haskell :session s1 :results value

 myAbs :: (Ord a, Num a) => a -> a
 myAbs x
   | x > 0 = x
   | x == 0 = 0
   | otherwise = negate x

 map myAbs [-5..5]

#+END_SRC

Version 2

#+BEGIN_SRC haskell :session s1 :results value

 myAbs' :: (Ord a, Num a) => a -> a
 myAbs' x = if (x < 0) then negate x else x

 map myAbs' [-5..5]

#+END_SRC
